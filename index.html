<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Majorit√© Gagnante</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --background-color: #1a1a1d;
            --surface-color: #2c2c34;
            --primary-color: #9575cd;
            --secondary-color: #65499c;
            --text-color: #f0f0f0;
            --border-color: #444;
            --option-a-color: #3498db;
            --option-b-color: #e74c3c;
            --success-color: #2ecc71;
        }
        body {
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
            overflow: hidden;
        }
        .screen {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            opacity: 0;
            transform: scale(1.1);
            visibility: hidden;
            transition: opacity 0.4s ease-out, transform 0.4s ease-out;
        }
        .screen.active {
            opacity: 1;
            transform: scale(1);
            visibility: visible;
        }
        .panel {
            background-color: var(--surface-color);
            padding: 2rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 600px;
            position: relative;
            z-index: 2;
        }
        h1, h2 {
            color: var(--primary-color);
            margin-top: 0;
        }
        input[type="text"] {
            padding: 1rem;
            font-size: 1.2rem;
            width: 80%;
            max-width: 300px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: #333;
            color: white;
            margin-bottom: 1rem;
        }
        .btn {
            padding: 1rem 2rem;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            background-color: var(--primary-color);
            color: white;
        }
        .btn:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
        }
        .btn:disabled {
            background-color: #555;
            cursor: not-allowed;
            transform: none;
        }
        .choice-container {
            display: flex;
            gap: 20px;
            margin-top: 2rem;
            width: 100%;
        }
        .choice-btn {
            flex: 1;
            padding: 2rem 1rem;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 8px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        .choice-btn.option-a { background-color: var(--option-a-color); color: white; }
        .choice-btn.option-b { background-color: var(--option-b-color); color: white; }
        .choice-btn:hover { transform: scale(1.05); }
        .choice-btn.selected { border-color: white; box-shadow: 0 0 20px white; }
        .choice-btn.disabled { filter: grayscale(80%); cursor: not-allowed; }
        .result-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 100%;
            background-color: rgba(0,0,0,0.2);
            transition: width 0.5s ease-in-out;
            z-index: 1;
        }
        .choice-btn span { position: relative; z-index: 2; }
        #leaderboard {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--surface-color);
            padding: 10px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            max-height: 50vh;
            overflow-y: auto;
            width: 220px;
            z-index: 500;
        }
        #leaderboard h3 {
            margin: 0 0 10px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            font-size: 1.1rem;
        }
        #leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #leaderboard li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 5px;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        #leaderboard li.current-player {
            background-color: var(--secondary-color);
        }
        #round-timer, #countdown-text {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary-color);
            background-color: rgba(0,0,0,0.3);
            padding: 5px 20px;
            border-radius: 20px;
        }
        #round-timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        #countdown-text {
            font-size: 5rem;
            animation: pulse 1s infinite;
            background-color: transparent;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-overlay.active {
            display: flex;
        }
        .modal-content {
            background-color: var(--surface-color);
            padding: 2rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 400px;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
        }
        #host-controls {
            border: 2px dashed var(--primary-color);
            padding: 1rem;
            margin-top: 1.5rem;
            border-radius: 8px;
        }
        #host-controls input {
            background-color: #333; color: white; border: 1px solid var(--border-color); padding: 0.5rem; border-radius: 4px; margin: 0 0.5rem;
        }
        .theme-btn.selected {
            border: 2px solid white;
            box-shadow: 0 0 10px white;
        }
        #emoji-picker {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 1.5rem 0;
            flex-wrap: wrap;
        }
        .emoji-btn {
            font-size: 1.8rem;
            padding: 5px;
            cursor: pointer;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .emoji-btn:hover {
            background-color: var(--secondary-color);
        }
        .emoji-btn.selected {
            border-color: white;
            transform: scale(1.2);
        }
        #player-list {
            list-style: none;
            padding: 0;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1rem;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 1rem;
        }
        .emoji-btn:disabled {
            filter: grayscale(100%);
            cursor: not-allowed;
            position: relative;
        }
        .emoji-btn:disabled::after {
            content: '‚ùå';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: red;
            text-shadow: 0 0 3px black;
            opacity: 0.7;
        }
        #snowflakes {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            overflow: hidden;
        }
        .snowflake {
            color: #fff;
            font-size: 1em;
            font-family: Arial, sans-serif;
            text-shadow: 0 0 5px #000;
            position: absolute;
            top: -10%;
            animation: fall linear infinite;
        }
        @keyframes fall {
            0% {
                transform: translateY(0vh) translateX(0vw);
                opacity: 1;
            }
            100% {
                transform: translateY(105vh) translateX(2vw);
                opacity: 0;
            }
        }
    </style>
</head>
<body>

    <div id="snowflakes"></div>
    <audio id="click-sound" src="click.mp3"></audio>
    <audio id="ready-sound" src="ready.mp3"></audio>
    <audio id="vote-sound" src="vote.mp3"></audio>
    <audio id="win-sound" src="win.mp3"></audio>

    <div id="login-screen" class="screen active">
        <div class="panel">
            <h1>Majorit√© Gagnante</h1>
            <input type="text" id="player-name-input" placeholder="Entrez votre nom..." maxlength="15">
            <div id="emoji-picker"></div>
            <button id="join-game-btn" class="btn">Rejoindre la partie</button>
        </div>
    </div>

    <div id="lobby-screen" class="screen">
        <div class="panel">
            <h2>En attente des joueurs...</h2>
            <p>Th√®me actuel : <strong id="current-theme-text">Vote en cours</strong></p>
            <h3>Votez pour le prochain th√®me :</h3>
            <div id="theme-vote-container" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;"></div>
            <hr>
            <div id="host-controls" style="display: none;">
                <h4>üëë Panneau de l'H√¥te</h4>
                <label for="rounds-input">Manches :</label>
                <input type="number" id="rounds-input" value="5" min="1" max="20">
                <button id="start-game-btn" class="btn" style="padding: 0.5rem 1rem; font-size: 0.9rem; margin-top: 0.5rem; display: none; background-color: var(--success-color);">D√©marrer la partie</button>
                <button id="force-start-btn" class="btn" style="padding: 0.5rem 1rem; font-size: 0.9rem; margin-top: 0.5rem;">Forcer le d√©marrage</button>
                <p style="font-size: 0.8rem; margin-top: 1rem;">Cliquez sur un joueur pour le g√©rer.</p>
            </div>
            <button id="ready-btn" class="btn">Pr√™t</button>
            <p id="ready-status">Appuyez sur Pr√™t pour commencer !</p>
            <hr>
            <h3>Joueurs connect√©s (<span id="player-count">0</span>)</h3>
            <ul id="player-list"></ul>
        </div>
    </div>

    <div id="voting-screen" class="screen">
        <div id="vote-timer" class="round-timer"></div>
        <div class="panel">
            <h2 id="question-title">Question...</h2>
            <div class="choice-container">
                <button id="vote-a-btn" class="choice-btn option-a"><span>Option A</span></button>
                <button id="vote-b-btn" class="choice-btn option-b"><span>Option B</span></button>
            </div>
            <p id="vote-status" style="margin-top: 2rem;">Votez !</p>
        </div>
    </div>

    <div id="reveal-screen" class="screen">
        <div class="panel">
            <h2 id="reveal-question-title">R√©sultats !</h2>
            <div class="choice-container">
                <button id="reveal-a-btn" class="choice-btn option-a disabled">
                    <div id="result-bar-a" class="result-bar"></div>
                    <span id="reveal-a-text">Option A</span>
                </button>
                <button id="reveal-b-btn" class="choice-btn option-b disabled">
                    <div id="result-bar-b" class="result-bar"></div>
                    <span id="reveal-b-text">Option B</span>
                </button>
            </div>
            <p id="reveal-result-text" style="margin-top: 2rem; font-size: 1.5rem;"></p>
        </div>
    </div>

    <div id="game-over-screen" class="screen">
        <div class="panel">
            <h2>Partie Termin√©e !</h2>
            <p style="font-size: 2rem;">Le gagnant est <strong id="winner-name" style="color: var(--primary-color);">...</strong> !</p>
            <p>Un nouveau lobby va bient√¥t commencer.</p>
        </div>
    </div>

    <div id="leaderboard" style="display: none;">
        <h3>üèÜ Classement</h3>
        <ul id="leaderboard-list"></ul>
    </div>

    <div id="player-action-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="player-action-title">G√©rer le joueur</h2>
            <div id="player-action-buttons" class="menu-buttons" style="margin-top: 1rem;">
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getDatabase, ref, set, onValue, onDisconnect, get } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBYa1y1erUYlbUg1CNTokhOYyHpbcuS_Lc",
            authDomain: "majorite-gagnante.firebaseapp.com",
            projectId: "majorite-gagnante",
            databaseURL: "https://majorite-gagnante-default-rtdb.europe-west1.firebasedatabase.app",
            storageBucket: "majorite-gagnante.appspot.com",
            messagingSenderId: "850415853522",
            appId: "1:850415853522:web:9ecb1522a6fb623f34b20b"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        const questions = {
            "Dilemmes Absurdes": [
                { q: "Tu pr√©f√®res avoir...", a: "Des spaghettis √† la place des cheveux", b: "Du sirop d'√©rable qui coule du nez quand tu pleures" },
                { q: "Tu pr√©f√®res...", a: "Parler comme Yoda pour le reste de ta vie", b: "Marcher uniquement √† quatre pattes en public" },
                { q: "Tu pr√©f√®res...", a: "√âternuer du fromage en poudre", b: "Transpirer de la mayonnaise" },
                { q: "Tu pr√©f√®res avoir un...", a: "Canard en plastique qui te suit partout", b: "Nuage de pluie personnel au-dessus de ta t√™te" },
                { q: "Tu pr√©f√®res...", a: "Avoir des mains en jambon", b: "Avoir des pieds en brocolis" },
                { q: "Tu pr√©f√®res...", a: "Ne plus jamais manger de chocolat", b: "Ne plus jamais √©couter de musique" },
                { q: "Tu pr√©f√®res avoir...", a: "Un rire de dessin anim√©", b: "Une voix de robot en permanence" },
                { q: "Tu pr√©f√®res...", a: "Ne communiquer qu'en chantant", b: "Ne communiquer qu'en dansant" },
                { q: "Tu pr√©f√®res...", a: "Avoir des doigts en saucisse", b: "Avoir des orteils en cornichon" },
                { q: "Chaque fois que tu mens...", a: "Ton nez s'allonge", b: "Tes oreilles grandissent" },
                { q: "Tu pr√©f√®res porter...", a: "Uniquement des v√™tements de clown", b: "Uniquement une armure m√©di√©vale" },
                { q: "Tu pr√©f√®res...", a: "Avoir un troisi√®me oeil dans le dos", b: "Avoir des tentacules √† la place des bras" },
                { q: "Tu pr√©f√®res que chaque aliment que tu manges...", a: "Go√ªte le piment extra fort", b: "Soit incroyablement sal√©" },
                { q: "Tu pr√©f√®res...", a: "Vivre dans une maison en pain d'√©pice", b: "Vivre dans un ch√¢teau gonflable" },
                { q: "Tu pr√©f√®res...", a: "Avoir des cheveux qui changent de couleur selon ton humeur", b: "Avoir des yeux qui projettent des films" },
            ],
            "Pop Culture": [
                { q: "Meilleur univers fantastique ?", a: "Le Seigneur des Anneaux", b: "Harry Potter" },
                { q: "Meilleure console de tous les temps ?", a: "Super Nintendo", b: "PlayStation 2" },
                { q: "S√©rie √† regarder en boucle ?", a: "Friends", b: "The Office" },
                { q: "Quel univers de super-h√©ros ?", a: "Marvel (MCU)", b: "DC (DCEU)" },
                { q: "Meilleur m√©chant de film ?", a: "Dark Vador", b: "Le Joker (Heath Ledger)" },
                { q: "Si tu devais vivre dans une sitcom...", a: "Brooklyn Nine-Nine", b: "How I Met Your Mother" },
                { q: "Meilleur film de Quentin Tarantino ?", a: "Pulp Fiction", b: "Inglourious Basterds" },
                { q: "Jeu vid√©o le plus influent ?", a: "Super Mario 64", b: "The Legend of Zelda: Ocarina of Time" },
                { q: "Meilleur r√©alisateur ?", a: "Steven Spielberg", b: "Christopher Nolan" },
                { q: "Quel groupe de musique l√©gendaire ?", a: "The Beatles", b: "Queen" },
                { q: "Meilleur film d'animation ?", a: "Le Roi Lion", b: "Le Voyage de Chihiro" },
                { q: "Star Wars : Trilogies...", a: "Originale (IV, V, VI)", b: "Pr√©logie (I, II, III)" },
                { q: "Meilleur James Bond ?", a: "Sean Connery", b: "Daniel Craig" },
                { q: "Personnage de fiction le plus intelligent ?", a: "Sherlock Holmes", b: "Light Yagami (Death Note)" },
                { q: "Film qui fait le plus pleurer ?", a: "Titanic", b: "La Ligne Verte" },
            ],
            "D√©bats de Soci√©t√©": [
                { q: "Pour ou contre...", a: "L'uniforme √† l'√©cole", b: "Le t√©l√©travail obligatoire 3 jours/semaine" },
                { q: "Le plus important dans un travail ?", a: "Le salaire", b: "La passion" },
                { q: "Ananas sur une pizza ?", a: "Oui, c'est d√©licieux !", b: "Non, c'est un crime !" },
                { q: "Les r√©seaux sociaux...", a: "Connectent le monde", b: "Sont une perte de temps" },
                { q: "Pour les vacances, tu es plut√¥t...", a: "Organisation millim√©tr√©e", b: "Improvisation totale" },
                { q: "Le matin, tu es...", a: "Snooze x10", b: "Debout au premier r√©veil" },
                { q: "L'argent fait-il le bonheur ?", a: "Oui, en grande partie", b: "Non, pas du tout" },
                { q: "Le livre est-il toujours mieux que le film ?", a: "Oui, toujours", b: "Non, √ßa d√©pend" },
                { q: "Pour un long trajet...", a: "Voiture", b: "Train" },
                { q: "La fin justifie-t-elle les moyens ?", a: "Oui, parfois", b: "Non, jamais" },
                { q: "Le plus important dans la vie ?", a: "La famille", b: "Les amis" },
                { q: "Faut-il dire la v√©rit√© m√™me si elle blesse ?", a: "Oui, toujours", b: "Non, il faut prot√©ger les autres" },
                { q: "Plut√¥t...", a: "Ville", b: "Campagne" },
                { q: "Le chat est-il meilleur que le chien ?", a: "Oui, de loin", b: "Non, le chien est le meilleur ami de l'homme" },
                { q: "Le caf√© se boit...", a: "Noir, sans sucre", b: "Avec du lait et du sucre" },
            ],
            "Super-pouvoirs": [
                { q: "Quel super-pouvoir choisir ?", a: "Voler", b: "√ätre invisible" },
                { q: "Tu pr√©f√®res contr√¥ler...", a: "Le temps", b: "L'esprit des gens" },
                { q: "Si tu devais avoir un pouvoir 'inutile'...", a: "Parler aux √©cureuils", b: "Changer la couleur de tes cheveux √† volont√©" },
                { q: "Tu pr√©f√®res avoir...", a: "Une super-force", b: "Une super-vitesse" },
                { q: "Tu pr√©f√®res...", a: "Te t√©l√©porter", b: "Lire dans les pens√©es" },
                { q: "Tu pr√©f√®res pouvoir...", a: "Respirer sous l'eau", b: "Parler √† tous les animaux" },
                { q: "Tu pr√©f√®res...", a: "G√©n√©rer des champs de force", b: "Contr√¥ler le feu" },
                { q: "Tu pr√©f√®res avoir...", a: "Une r√©g√©n√©ration instantan√©e", b: "Une invuln√©rabilit√© totale" },
                { q: "Tu pr√©f√®res...", a: "√ätre un super-h√©ros c√©l√®bre", b: "√ätre un justicier masqu√© anonyme" },
                { q: "Ton pouvoir ne fonctionne que...", a: "Quand tu chantes √† tue-t√™te", b: "Quand tu es compl√®tement nu" },
                { q: "Tu pr√©f√®res...", a: "Manipuler la m√©t√©o", b: "Faire pousser les plantes instantan√©ment" },
                { q: "Tu pr√©f√®res avoir le pouvoir de...", a: "Convaincre n'importe qui de n'importe quoi", b: "Ne jamais avoir besoin de dormir" },
                { q: "Tu pr√©f√®res...", a: "Voir le futur", b: "Changer le pass√©" },
                { q: "Tu pr√©f√®res...", a: "Cr√©er des illusions parfaites", b: "Devenir n'importe quel animal" },
                { q: "Tu pr√©f√®res avoir le pouvoir de...", a: "Manger sans jamais grossir", b: "Apprendre n'importe quoi instantan√©ment" },
            ],
            "Sexualit√©": [
                { q: "Premier rendez-vous id√©al ?", a: "D√Æner romantique", b: "Activit√© originale (escalade, mus√©e...)" },
                { q: "En couple, tu as besoin de...", a: "Beaucoup d'ind√©pendance", b: "Faire tout √† deux" },
                { q: "Le plus grand tue-l'amour ?", a: "La jalousie", b: "Le manque de communication" },
                { q: "Pour s√©duire, tu utilises...", a: "Ton humour", b: "Ton charme myst√©rieux" },
                { q: "Tu pr√©f√®res savoir...", a: "Le nombre exact de partenaires de ton/ta partenaire", b: "Ne jamais le savoir" },
                { q: "Le plus embarrassant pendant l'acte ?", a: "Un bruit corporel inattendu", b: "Se tromper de pr√©nom" },
                { q: "Tu d√©couvres que ton/ta meilleur(e) ami(e)...", a: "A un crush sur toi", b: "A eu une aventure avec ton ex" },
                { q: "Tu pr√©f√®res...", a: "√ätre surpris(e) avec des menottes", b: "√ätre surpris(e) avec un bandeau sur les yeux" },
                { q: "Le plus important pour toi ?", a: "La connexion √©motionnelle", b: "L'alchimie physique" },
                { q: "Tu pr√©f√®res un(e) partenaire...", a: "Dominant(e)", b: "Soumis(e)" },
                { q: "Tu apprends que ton/ta partenaire...", a: "Regarde des films pour adultes", b: "A un compte sur un site de rencontre (sans l'utiliser)" },
                { q: "Le pire message √† recevoir de son ex ?", a: "'Tu me manques'", b: "'Je suis enceinte/Je vais √™tre papa'" },
                { q: "Tu pr√©f√®res...", a: "Un plan √† trois", b: "√âchanger de partenaire avec un autre couple" },
                { q: "Le plus excitant ?", a: "Un lieu public risqu√©", b: "Un jeu de r√¥le √©labor√©" },
                { q: "Tu tombes amoureux...", a: "Tr√®s facilement", b: "Tr√®s rarement" },
                { q: "Un partenaire doit-il partager tes passions ?", a: "Oui, c'est essentiel", b: "Non, il faut avoir son propre jardin secret" },
                { q: "Le plus attirant ?", a: "La confiance en soi", b: "La gentillesse" },
                { q: "Tu pr√©f√®res une relation...", a: "Passionnelle et intense", b: "Stable et r√©confortante" },
                { q: "Le mensonge dans un couple est...", a: "Totalement inacceptable", b: "Parfois n√©cessaire ('mensonge blanc')" },
                { q: "Tu pr√©f√®res...", a: "Un long baiser passionn√©", b: "Mille petits bisous tendres" },
                { q: "Le physique est-il important ?", a: "Oui, c'est la premi√®re chose que l'on voit", b: "Non, la personnalit√© prime sur tout" },
                { q: "Tu pr√©f√®res...", a: "Dire 'Je t'aime' en premier", b: "Attendre de l'entendre en premier" },
                { q: "Le mariage est-il...", a: "Un but essentiel dans la vie", b: "Une formalit√© d√©pass√©e" },
            ],
            "Nourriture": [
                { q: "Pour le reste de ta vie, tu ne manges que...", a: "Des pizzas", b: "Des tacos" },
                { q: "Le bord de la pizza...", a: "On le mange", b: "On le laisse" },
                { q: "Petit-d√©jeuner id√©al ?", a: "Sucr√© (viennoiseries, c√©r√©ales)", b: "Sal√© (oeufs, bacon)" },
                { q: "Le fromage...", a: "Plus √ßa sent fort, meilleur c'est", b: "Doux et cr√©meux uniquement" },
                { q: "Plut√¥t...", a: "Coca-Cola", b: "Pepsi" },
                { q: "Sauce pour les frites ?", a: "Ketchup", b: "Mayonnaise" },
                { q: "Si tu ne devais garder qu'un seul condiment...", a: "La moutarde", b: "La sauce soja" },
                { q: "Le chocolat...", a: "Noir et intense", b: "Au lait et fondant" },
                { q: "Tu pr√©f√®res manger...", a: "Un plat unique et √©norme", b: "Plein de petites choses (tapas)" },
                { q: "Le plat que tu pourrais manger tous les jours ?", a: "Des p√¢tes", b: "Du riz" },
                { q: "Pour l'ap√©ro...", a: "Chips", b: "Saucisson" },
                { q: "Glace : cornet ou pot ?", a: "Cornet", b: "Pot" },
                { q: "Le steak doit √™tre...", a: "Saignant", b: "Bien cuit" },
                { q: "Tu pr√©f√®res boire...", a: "Du th√©", b: "Du caf√©" },
                { q: "Le meilleur fast-food ?", a: "McDonald's", b: "Burger King" },
            ],
            "Voyages": [
                { q: "Vacances id√©ales ?", a: "Plage et cocotiers", b: "Montagne et randonn√©e" },
                { q: "Tu pr√©f√®res voyager dans...", a: "Le futur", b: "Le pass√©" },
                { q: "Type de voyage ?", a: "Road trip en van", b: "H√¥tel de luxe tout compris" },
                { q: "Pour visiter une ville...", a: "Se perdre dans les rues", b: "Suivre un guide touristique" },
                { q: "Tu pr√©f√®res voyager...", a: "Seul", b: "En groupe" },
                { q: "Destination de r√™ve ?", a: "Le Japon", b: "L'Italie" },
                { q: "Pour un week-end...", a: "Grande capitale europ√©enne", b: "Petite cabane dans la for√™t" },
                { q: "Tu pr√©f√®res...", a: "Visiter des mus√©es et des monuments", b: "Go√ªter √† toute la nourriture locale" },
                { q: "Le plus important en voyage ?", a: "Le confort", b: "L'aventure" },
                { q: "Tu pr√©f√®res voyager en...", a: "Avion", b: "Train" },
                { q: "Souvenir de voyage typique ?", a: "Un aimant pour le frigo", b: "Une sp√©cialit√© locale √† manger" },
                { q: "Tu pr√©f√®res des vacances...", a: "Sportives et actives", b: "Relaxantes et farniente" },
                { q: "Le logement id√©al ?", a: "Un Airbnb local", b: "Un h√¥tel avec piscine" },
                { q: "Tu pr√©f√®res...", a: "Partir √† l'autre bout du monde", b: "D√©couvrir les r√©gions pr√®s de chez toi" },
                { q: "Le voyage parfait, c'est avec...", a: "Tes amis", b: "Ta famille" },
            ]
        };
        const themes = Object.keys(questions);
        const STARTING_SCORE = 1000;
        const POINTS_PER_WIN = 250;
        const ROUND_DURATION = { vote: 15, reveal: 10 };

        const screens = {
            login: document.getElementById('login-screen'),
            lobby: document.getElementById('lobby-screen'),
            voting: document.getElementById('voting-screen'),
            reveal: document.getElementById('reveal-screen'),
            gameOver: document.getElementById('game-over-screen'),
        };
        const playerNameInput = document.getElementById('player-name-input');
        const joinGameBtn = document.getElementById('join-game-btn');
        const leaderboardEl = document.getElementById('leaderboard');
        const emojiPicker = document.getElementById('emoji-picker');

        let localPlayer = { id: null, name: null, score: STARTING_SCORE };
        let currentGameState = {};
        let currentRoundData = {};
        let localPlayerIsReady = false;
        let localPlayerThemeVote = null;
        let roundTimerInterval = null;
        let gameMasterInterval = null;
        let isSpectator = false;
        let isHost = false;

        const emojis = [
            'üòÄ', 'üòé', 'ü§î', 'üòÇ', 'üòá', 'üòà', 'üëΩ', 'ü§ñ', 'üëª', 'üíÄ', 'ü¶ä', 'üëë',
            '‚ù§Ô∏è', 'üî•', '‚≠ê', 'üöÄ', 'üíé', 'üéâ', 'üíØ', 'ü§°', 'üêô', 'ü¶Ñ', 'üê≤', 'üçî',
            'üçï', '‚öΩ', 'üé∏', 'üéÆ', 'üí°', 'üí∞', 'üìà', 'üìâ', 'üí£', 'üîë', 'üìà', 'üìâ'
        ];
        let selectedEmoji = emojis[0];

        function createSnowflakes() {
            const snowflakesContainer = document.getElementById('snowflakes');
            if (!snowflakesContainer) return;
            snowflakesContainer.innerHTML = '';
            const snowflakeCount = 100;
            for (let i = 0; i < snowflakeCount; i++) {
                const snowflake = document.createElement('div');
                snowflake.className = 'snowflake';
                snowflake.textContent = '‚ùÑ';
                snowflake.style.left = Math.random() * 100 + 'vw';
                snowflake.style.animationDuration = (Math.random() * 5 + 5) + 's';
                snowflake.style.animationDelay = Math.random() * 5 + 's';
                snowflake.style.opacity = Math.random();
                snowflake.style.fontSize = (Math.random() * 1 + 0.5) + 'em';
                snowflakesContainer.appendChild(snowflake);
            }
        }

        function playSound(soundId) {
            const sound = document.getElementById(soundId);
            if (sound) { sound.currentTime = 0; sound.play().catch(e => console.log("Interaction n√©cessaire pour jouer le son.")); }
        }

        function renderEmojiPicker(takenEmojis = []) {
            emojiPicker.innerHTML = '';
            let isCurrentSelectionTaken = takenEmojis.includes(selectedEmoji);

            emojis.forEach(emoji => {
                const btn = document.createElement('button');
                btn.className = 'emoji-btn';
                btn.textContent = emoji;
                const isTaken = takenEmojis.includes(emoji);
                if (isTaken) {
                    btn.disabled = true;
                }
                btn.onclick = () => {
                    document.querySelector('.emoji-btn.selected')?.classList.remove('selected');
                    playSound('click-sound');
                    btn.classList.add('selected');
                    selectedEmoji = emoji;
                };
                emojiPicker.appendChild(btn);
            });

            if (isCurrentSelectionTaken) {
                const firstAvailable = emojiPicker.querySelector('.emoji-btn:not(:disabled)');
                if (firstAvailable) firstAvailable.click();
            } else {
                const currentSelectedBtn = Array.from(emojiPicker.querySelectorAll('.emoji-btn')).find(b => b.textContent === selectedEmoji);
                if (currentSelectedBtn) currentSelectedBtn.classList.add('selected');
            }
        }

        joinGameBtn.addEventListener('click', () => {
            const name = playerNameInput.value.trim();
            if (!name) {
                alert("Veuillez entrer un nom.");
                return;
            }
            playSound('click-sound');
            localPlayer.name = name;
            localPlayer.id = 'player_' + Date.now() + Math.random().toString(36).substring(2, 9);
            
            const playerRef = ref(database, `players/${localPlayer.id}`);
            onDisconnect(playerRef).update({ isOnline: false });
            set(playerRef, {
                name: localPlayer.name,
                score: localPlayer.score,
                emoji: selectedEmoji,
                isOnline: true,
                isReady: false,
                kicked: false
            });

            switchScreen('lobby');
            listenToGameChanges();
        });

        function switchScreen(screenName) {
            Object.values(screens).forEach(s => s.classList.remove('active'));
            if (screens[screenName]) {
                screens[screenName].classList.add('active');
            }
            leaderboardEl.style.display = (screenName !== 'login') ? 'block' : 'none';

            if (screenName === 'login') {
                onValue(ref(database, 'players'), (snapshot) => {
                    const players = snapshot.val() || {};
                    const takenEmojis = Object.values(players).filter(p => p.isOnline).map(p => p.emoji);
                    renderEmojiPicker(takenEmojis);
                }, { onlyOnce: false });
            }
        }

        function listenToGameChanges() {
            onValue(ref(database, 'players'), (snapshot) => {
                const players = snapshot.val() || {};
                if (players[localPlayer.id]?.kicked) {
                    alert("Vous avez √©t√© exclu de la partie.");
                    window.location.reload();
                }
                updatePlayerList(players);
                updateLeaderboard(players);
            });

            const gameRef = ref(database, 'game');
            onValue(gameRef, (snapshot) => {
                if (!isHost) {
                    tryToBecomeHost();
                }

                const gameState = snapshot.val();
                if (!gameState) return;
                
                // Si le jeu passe du lobby au vote, tous les joueurs pr√©sents deviennent des participants.
                if (currentGameState.state === 'lobby' && gameState.state === 'voting') {
                    isSpectator = false;
                }
                // Si un joueur arrive et que le jeu est d√©j√† en cours (pas dans le lobby), il devient spectateur.
                else if (!currentGameState.state && gameState.state !== 'lobby') {
                    isSpectator = true;
                }

                currentGameState = gameState;
                handleGameStateChange(gameState);
            });
        }

        function handleGameStateChange(state) {
            document.getElementById('current-theme-text').textContent = state.currentTheme || 'Vote en cours';

            if (state.countdown) {
                const lobbyPanel = screens.lobby.querySelector('.panel');
                if (lobbyPanel) lobbyPanel.innerHTML = `<div id="countdown-text">${state.countdown}</div>`;
            } else if (state.state === 'lobby' && !screens.lobby.querySelector('.panel h2')) {
                screens.lobby.querySelector('.panel').innerHTML = `<h2>En attente des joueurs...</h2><p>Th√®me actuel : <strong id="current-theme-text">${state.currentTheme || 'Vote en cours'}</strong></p><h3>Votez pour le prochain th√®me :</h3><div id="theme-vote-container" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;"></div><hr><div id="host-controls" style="display: none;"><h4>üëë Panneau de l'H√¥te</h4><label for="rounds-input">Manches :</label><input type="number" id="rounds-input" value="5" min="1" max="20"><button id="start-game-btn" class="btn" style="padding: 0.5rem 1rem; font-size: 0.9rem; margin-top: 0.5rem; display: none; background-color: var(--success-color);">D√©marrer la partie</button><button id="force-start-btn" class="btn" style="padding: 0.5rem 1rem; font-size: 0.9rem; margin-top: 0.5rem;">Forcer le d√©marrage</button><p style="font-size: 0.8rem; margin-top: 1rem;">Cliquez sur un joueur pour le g√©rer.</p></div><button id="ready-btn" class="btn">Pr√™t</button><p id="ready-status">Appuyez sur Pr√™t pour commencer !</p><hr><h3>Joueurs connect√©s (<span id="player-count">0</span>)</h3><ul id="player-list"></ul>`;
                setupLobbyScreen();
                updateHostControlsVisibility();
            }

            if (state.totalRounds && document.getElementById('rounds-input')) {
                document.getElementById('rounds-input').value = state.totalRounds;
            }

            if (state.timerEnd) {
                startRoundTimer(state.timerEnd, state.state);
            } else {
                if (roundTimerInterval) clearInterval(roundTimerInterval);
                const voteTimer = document.getElementById('vote-timer');
                if(voteTimer) voteTimer.style.display = 'none';
            }

            switch (state.state) {
                case 'voting':
                    get(ref(database, `rounds/${state.currentRoundId}`)).then((snap) => {
                        currentRoundData = snap.val() || {};
                        setupVotingScreen(state.currentQuestion);
                        switchScreen('voting');
                    });
                    break;
                case 'reveal':
                     get(ref(database, `rounds/${state.currentRoundId}`)).then((snap) => {
                        currentRoundData = snap.val() || {};
                        setupRevealScreen(state.currentQuestion, currentRoundData);
                        switchScreen('reveal');
                    });
                    break;
                case 'gameover':
                    const winner = state.winner;
                    document.getElementById('winner-name').textContent = winner.name;
                    switchScreen('gameOver');
                    break;
                case 'lobby':
                default:
                    if (document.body.contains(screens.lobby)) {
                        setupLobbyScreen();
                        switchScreen('lobby');
                    }
                    break;
            }
        }

        function setupLobbyScreen() {
            const themeContainer = document.getElementById('theme-vote-container');
            if (!themeContainer) return;
            themeContainer.innerHTML = '';
            themes.forEach(theme => {
                const btn = document.createElement('button');
                btn.className = 'btn theme-btn';
                btn.textContent = theme;
                btn.style.fontSize = '1rem';
                if (theme === localPlayerThemeVote) {
                    btn.classList.add('selected');
                }
                btn.onclick = () => {
                    localPlayerThemeVote = theme;
                    set(ref(database, `themeVotes/${localPlayer.id}`), theme);
                    document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                };
                themeContainer.appendChild(btn);
            });
            const readyBtn = document.getElementById('ready-btn');
            readyBtn.addEventListener('click', toggleReadyState);
            if (localPlayerIsReady) {
                readyBtn.textContent = "Pas Pr√™t";
                readyBtn.style.backgroundColor = 'var(--option-b-color)';
            } else {
                readyBtn.textContent = "Pr√™t";
                readyBtn.style.backgroundColor = 'var(--primary-color)';
            }
        }

        function setupVotingScreen(question) {
            document.getElementById('question-title').textContent = question.q;
            document.getElementById('vote-a-btn').querySelector('span').textContent = question.a;
            document.getElementById('vote-b-btn').querySelector('span').textContent = question.b;
            
            ['vote-a-btn', 'vote-b-btn'].forEach(id => {
                const btn = document.getElementById(id);
                btn.classList.remove('selected', 'disabled');
                btn.onclick = () => selectVote(id.includes('a') ? 'A' : 'B');
            });
            
            const myVote = currentRoundData.votes?.[localPlayer.id];
            if (myVote) {
                document.getElementById(`vote-${myVote.toLowerCase()}-btn`).classList.add('selected');
                document.getElementById('vote-status').textContent = "Vote enregistr√© ! En attente des autres joueurs...";
                document.getElementById('vote-a-btn').classList.add('disabled');
                document.getElementById('vote-b-btn').classList.add('disabled');
            } else {
                if (isSpectator) {
                    document.getElementById('vote-status').textContent = "Partie en cours... Vous jouerez au prochain tour.";
                    document.getElementById('vote-a-btn').classList.add('disabled');
                    document.getElementById('vote-b-btn').classList.add('disabled');
                    return;
                }
                document.getElementById('vote-status').textContent = "Votez !";
            }
        }

        function setupRevealScreen(question, roundData) {
            document.getElementById('reveal-question-title').textContent = question.q;
            document.getElementById('reveal-a-text').textContent = question.a;
            document.getElementById('reveal-b-text').textContent = question.b;

            const votes = roundData.votes || {};
            const totalVotes = Object.keys(votes).length;
            const votesA = Object.values(votes).filter(v => v === 'A').length;
            const votesB = totalVotes - votesA;

            const percentA = totalVotes > 0 ? (votesA / totalVotes) * 100 : 0;
            const percentB = totalVotes > 0 ? (votesB / totalVotes) * 100 : 0;

            document.getElementById('result-bar-a').style.width = `${percentA}%`;
            document.getElementById('reveal-a-text').textContent = `${question.a} (${percentA.toFixed(0)}%)`;
            document.getElementById('result-bar-b').style.width = `${percentB}%`;
            document.getElementById('reveal-b-text').textContent = `${question.b} (${percentB.toFixed(0)}%)`;

            const winningOption = percentA > percentB ? 'A' : (percentB > percentA ? 'B' : 'Egalit√©');
            const myVote = roundData.votes?.[localPlayer.id];
            let resultText = "Prochain tour dans quelques secondes..."; 

            if (isSpectator) {
                resultText = "Vous rejoindrez la partie au prochain tour.";
            }
            if (myVote) {
                if (winningOption === 'Egalit√©') {
                    resultText = `√âgalit√© ! Personne ne gagne ou ne perd.`;
                } else if (myVote === winningOption) {
                    playSound('win-sound');
                    resultText = `Vous avez vot√© avec la majorit√© ! +${POINTS_PER_WIN} points.`;
                } else {
                    resultText = `Vous √™tes dans la minorit√© ! Pas de points cette fois.`;
                }
            }
            document.getElementById('reveal-result-text').textContent = resultText;
        }

        function selectVote(option) {
            document.getElementById('vote-a-btn').classList.add('disabled');
            document.getElementById('vote-b-btn').classList.add('disabled');
            document.getElementById(`vote-${option.toLowerCase()}-btn`).classList.add('selected');
            document.getElementById('vote-status').textContent = "Vote enregistr√© ! En attente des autres joueurs...";
            if (!isSpectator) {
                playSound('vote-sound');
            }
            set(ref(database, `rounds/${currentGameState.currentRoundId}/votes/${localPlayer.id}`), option);
        }

        function startRoundTimer(endTime, phase) {
            if (roundTimerInterval) clearInterval(roundTimerInterval);

            const timerEl = document.getElementById('vote-timer');
            if (!timerEl) return;

            timerEl.style.display = 'block';

            roundTimerInterval = setInterval(() => {
                const timeLeft = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
                timerEl.textContent = timeLeft;

                if (timeLeft === 0) {
                    clearInterval(roundTimerInterval);
                    if (phase === 'voting' && !currentRoundData.votes?.[localPlayer.id] && !isSpectator) {
                        selectVote('A');
                    }
                }
            }, 500);
        }

        function updatePlayerList(players) {
            const playerList = document.getElementById('player-list');
            if (!playerList) return;
            playerList.innerHTML = '';
            let onlinePlayers = 0;
            Object.entries(players).forEach(([id, p]) => {
                if (p.isOnline && !p.kicked && p.emoji) {
                    const playerCard = document.createElement('li');
                    playerCard.className = 'panel';
                    playerCard.style.padding = '1rem';
                    playerCard.innerHTML = `
                        <span style="font-size: 2rem; display: block;">${p.emoji}</span>
                        <span style="font-weight: bold; display: block; margin-top: 0.5rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${p.name}</span>
                    `;
                    if (p.isReady) {
                        playerCard.style.borderColor = 'var(--success-color)';
                    }
                    if (isHost && id !== localPlayer.id) {
                        playerCard.onclick = () => openPlayerActionModal(p.name, id);
                    }
                    playerList.appendChild(playerCard);
                    onlinePlayers++;
                }
            });
            const playerCountEl = document.getElementById('player-count');
            if(playerCountEl) playerCountEl.textContent = onlinePlayers;

            const readyPlayers = Object.values(players).filter(p => p.isOnline && p.isReady).length;
            const readyPercentage = onlinePlayers > 0 ? (readyPlayers / onlinePlayers) * 100 : 0;
            const readyStatusEl = document.getElementById('ready-status');
            if (readyStatusEl && currentGameState.state === 'lobby') {
                readyStatusEl.textContent = 
                    `Joueurs pr√™ts : ${readyPlayers} / ${onlinePlayers} (${readyPercentage.toFixed(0)}%)`;
            }

            if (isHost) {
                const startGameBtn = document.getElementById('start-game-btn');
                const forceStartBtn = document.getElementById('force-start-btn');
                if (onlinePlayers >= 2 && readyPlayers === onlinePlayers) {
                    startGameBtn.style.display = 'inline-block';
                    forceStartBtn.style.display = 'none';
                } else {
                    startGameBtn.style.display = 'none';
                    forceStartBtn.style.display = 'inline-block';
                }
            }
        }

        function updateLeaderboard(players) {
            const list = document.getElementById('leaderboard-list');
            list.innerHTML = '';
            const sortedPlayers = Object.values(players)
                .filter(p => p.isOnline && !p.kicked)
                .sort((a, b) => b.score - a.score);
            
            sortedPlayers.forEach((p, index) => {
                const rankIcons = ['ü•á', 'ü•à', 'ü•â'];
                const rank = rankIcons[index] || `#${index + 1}`;
                const li = document.createElement('li');
                li.innerHTML = `
                    <span style="flex-shrink: 0; width: 40px; text-align: left;">${rank}</span>
                    <span style="flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        ${p.emoji || ''} ${p.name}
                    </span>
                    <span style="font-weight: bold; margin-left: 10px;">${p.score}</span>
                `;

                if (p.id === localPlayer.id) {
                    li.classList.add('current-player');
                    localPlayer.score = p.score;
                }
                list.appendChild(li);
            });
        }

        function toggleReadyState() {
            localPlayerIsReady = !localPlayerIsReady;
            if (!localPlayerIsReady) localPlayerThemeVote = null;
            set(ref(database, `players/${localPlayer.id}/isReady`), localPlayerIsReady);
            const readyBtn = document.getElementById('ready-btn');
            playSound('ready-sound');

            if (localPlayerIsReady) {
                readyBtn.textContent = "Pas Pr√™t";
                readyBtn.style.backgroundColor = 'var(--option-b-color)';
            } else {
                readyBtn.textContent = "Pr√™t";
                readyBtn.style.backgroundColor = 'var(--primary-color)';
            }
        }

        function openPlayerActionModal(playerName, playerId) {
            const modal = document.getElementById('player-action-modal');
            document.getElementById('player-action-title').textContent = `G√©rer ${playerName}`;
            const buttonsContainer = document.getElementById('player-action-buttons');
            buttonsContainer.innerHTML = `
                <button id="set-host-action-btn" class="btn">D√©finir comme H√¥te</button>
                <button id="kick-player-action-btn" class="btn" style="background-color: var(--option-b-color);">Exclure</button>
            `;
            modal.classList.add('active');

            document.getElementById('set-host-action-btn').onclick = () => {
                playSound('click-sound');
                set(ref(database, 'game/hostId'), playerId);
                modal.classList.remove('active');
            };
            document.getElementById('kick-player-action-btn').onclick = () => {
                playSound('click-sound');
                set(ref(database, `players/${playerId}/kicked`), true);
                modal.classList.remove('active');
            };
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            };
        }

        async function tryToBecomeHost() {
            const hostRef = ref(database, 'game/hostId');
            const snapshot = await get(hostRef);
            const currentHostId = snapshot.val();

            if (currentHostId) {
                const hostPlayerSnap = await get(ref(database, `players/${currentHostId}`));
                if (hostPlayerSnap.exists() && hostPlayerSnap.val().isOnline) {
                    isHost = (currentHostId === localPlayer.id);
                    updateHostControlsVisibility();
                    return;
                }
            }

            await set(hostRef, localPlayer.id);
            onDisconnect(hostRef).remove();
            isHost = true;

            await set(ref(database, 'game'), {
                hostId: localPlayer.id,
                state: 'lobby'
            });

            if (gameMasterInterval) clearInterval(gameMasterInterval);
            updateHostControlsVisibility();
            gameMasterInterval = setInterval(gameMasterLoop, 5000);
        }

        async function gameMasterLoop() {
            if (!isHost) {
                if (gameMasterInterval) clearInterval(gameMasterInterval);
                return;
            }

            const gameSnap = await get(ref(database, 'game'));
            const gameState = gameSnap.val() || { state: 'lobby' };

            if (gameState.state === 'lobby') {
                const playersSnap = await get(ref(database, 'players'));
                const players = playersSnap.val() || {};
                const onlinePlayers = Object.values(players).filter(p => p.isOnline && !p.kicked);
                const readyPlayers = onlinePlayers.filter(p => p.isReady);
            }
        }

        async function startNewRound() {
            if (!isHost) return;

            if (gameMasterInterval) clearInterval(gameMasterInterval);
            gameMasterInterval = null;

            // Petite pause pour laisser le temps √† l'animation de transition
            await new Promise(resolve => setTimeout(resolve, 1000));
 
             const themeVotesSnap = await get(ref(database, 'themeVotes'));
             const themeVotes = themeVotesSnap.val() || {};
             const voteCounts = {};
             Object.values(themeVotes).forEach(theme => {
                 voteCounts[theme] = (voteCounts[theme] || 0) + 1;
             });
             const winningTheme = Object.keys(voteCounts).sort((a, b) => voteCounts[b] - voteCounts[a])[0] || themes[0];
 
             const currentRoundNumber = (currentGameState.currentRoundNumber || 0) + 1;
             const totalRounds = currentGameState.totalRounds || 5;

             const usedQuestionsByTheme = currentGameState.usedQuestions || {};
             const usedQuestionsForThisTheme = usedQuestionsByTheme[winningTheme] || [];
             let availableQuestions = questions[winningTheme].filter(q => !usedQuestionsForThisTheme.includes(q.q));
 
             if (availableQuestions.length === 0) {
                 availableQuestions = questions[winningTheme];
                 usedQuestionsByTheme[winningTheme] = [];
             }
 
             const question = availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
 
             if (!usedQuestionsByTheme[winningTheme]) {
                 usedQuestionsByTheme[winningTheme] = [];
             }
             usedQuestionsByTheme[winningTheme].push(question.q);
 
             const roundId = 'round_' + Date.now();
             await set(ref(database, 'game'), {
                 hostId: localPlayer.id,
                 timerEnd: Date.now() + ROUND_DURATION.vote * 1000,
                 state: 'voting',
                 currentRoundNumber: currentRoundNumber,
                 totalRounds: totalRounds,
                 currentTheme: winningTheme,
                 currentRoundId: roundId,
                 currentQuestion: question,
                 usedQuestions: usedQuestionsByTheme
             });
             await set(ref(database, `rounds/${roundId}`), { votes: {} });
 
             await new Promise(resolve => setTimeout(resolve, (ROUND_DURATION.vote + 1) * 1000));
 
             const roundSnap = await get(ref(database, `rounds/${roundId}`));
             const roundData = roundSnap.val();
             const votes = roundData.votes || {};
 
             const totalVotes = Object.keys(votes).length;
             const votesA = Object.values(votes).filter(v => v === 'A').length;
             const votesB = totalVotes - votesA;
             const winningOption = votesA > votesB ? 'A' : (votesB > votesA ? 'B' : 'Egalit√©');
 
             const playersSnap = await get(ref(database, 'players'));
             const players = playersSnap.val() || {};
 
             if (winningOption !== 'Egalit√©') {
                 for (const playerId in votes) {
                     const vote = votes[playerId];
                     if (players[playerId]) {
                         if (vote === winningOption) {
                             players[playerId].score += POINTS_PER_WIN;
                         }
                     }
                 }
             }
             await set(ref(database, 'players'), players);
 
             await set(ref(database, `game/state`), 'reveal');
             await set(ref(database, `game/timerEnd`), null);
             await new Promise(resolve => setTimeout(resolve, ROUND_DURATION.reveal * 1000));
 
             if (currentRoundNumber >= totalRounds) {
                const finalPlayersSnap = await get(ref(database, 'players'));
                const finalPlayers = finalPlayersSnap.val() || {};
                const winner = Object.values(finalPlayers).filter(p => p.isOnline && !p.kicked).sort((a, b) => b.score - a.score)[0];
                await set(ref(database, 'game'), { ...currentGameState, state: 'gameover', winner: winner });
                await new Promise(resolve => setTimeout(resolve, 10000));

                // La partie est finie, on retourne au lobby
                await set(ref(database, 'game'), { 
                    hostId: localPlayer.id, 
                    state: 'lobby',
                    totalRounds: totalRounds,
                    usedQuestions: {} // R√©initialiser les questions utilis√©es pour la prochaine partie
                });
                await set(ref(database, 'themeVotes'), {});
                const playersForResetSnap = await get(ref(database, 'players'));
                const playersForReset = playersForResetSnap.val() || {};
                for (const playerId in playersForReset) {
                    if (playersForReset[playerId].isOnline && !playersForReset[playerId].kicked) {
                        await set(ref(database, `players/${playerId}/isReady`), false);
                    }
                }
                if (gameMasterInterval) clearInterval(gameMasterInterval);
                gameMasterInterval = setInterval(gameMasterLoop, 5000);
            } else {
                // La partie n'est pas finie, on lance la manche suivante
                startNewRound();
            }
        }

        function updateHostControlsVisibility() {
            const hostControls = document.getElementById('host-controls');
            if (!hostControls) return;
            if (isHost) {
                hostControls.style.display = 'block';

                document.getElementById('rounds-input').onchange = () => {
                    const rounds = document.getElementById('rounds-input').value;
                    set(ref(database, 'game/totalRounds'), parseInt(rounds));
                };
                document.getElementById('start-game-btn').onclick = () => {
                    startNewRound();
                };
                document.getElementById('force-start-btn').onclick = () => {
                    if (confirm("Forcer le d√©marrage de la partie m√™me si tout le monde n'est pas pr√™t ?")) {
                        startNewRound();
                    }
                };
            } else {
                hostControls.style.display = 'none';
            }
        }
        renderEmojiPicker();
        createSnowflakes();
    </script>
</body>
</html>
